{"version":3,"sources":["utils/reducerHelpers.ts","p2p/core.ts","p2p/usePeerState.ts","basicChat/basicChatStore.ts","app/team/index.tsx","app/App.tsx","serviceWorker.ts","app/router/index.tsx","index.tsx"],"names":["combineReducers","reducers","state","action","reduce","reducer","createPeer","peerConsturctor","host","secure","events","EventEmitter","useCommonPeer","hostId","initialState","combinedReducer","initialStateReducer","emptyReducer","useReducer","_dispatch","useState","peer","id","ready","connections","isHost","error","peerState","setState","setPeer","setHost","dispatch","useCallback","source","console","log","send","forEach","connection","label","sendToConnection","useEffect","removeAllListeners","type","payload","on","then","peerConstructor","default","createHost","prev","conn","emit","data","filter","x","Error","connect","connectToHost","destroy","assertInitialStateAction","actions","addMessage","createAction","createReducer","messages","Team","match","useRouteMatch","history","useHistory","React","textState","params","msg","undefined","push","message","map","join","key","TextField","value","onChange","event","currentTarget","Button","onClick","App","path","to","Boolean","window","location","hostname","RouterOutlet","children","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","registration","unregister","catch"],"mappings":"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","file":"static/js/main.3cb0e3ee.chunk.js","sourcesContent":["import { Reducer } from \"react\"\r\n\r\nexport const combineReducers = <TState, TActions>(...reducers: Reducer<TState, TActions>[]): Reducer<TState, TActions> => (state: TState, action: TActions) =>\r\n    reducers.reduce(\r\n        (state, reducer) => reducer(state, action),\r\n        state)","import Peer from 'peerjs'\r\n\r\nconst server = 'peerjs-test-server.herokuapp.com'\r\n\r\nexport const createPeer = (peerConsturctor: typeof Peer) => new peerConsturctor({\r\n    host: server,\r\n    secure: true\r\n}) ","import { useEffect, useState, useReducer, useCallback, Reducer, useMemo } from 'react'\r\nimport Peer from 'peerjs'\r\nimport { Action } from 'typesafe-actions'\r\n\r\nimport { combineReducers } from '../utils/reducerHelpers'\r\nimport { createPeer } from './core'\r\nimport { EventEmitter } from 'events'\r\n\r\ntype PeerHost = {\r\n    id: string | null,\r\n    ready: boolean\r\n}\r\n\r\ntype PeerState = {\r\n    readonly peer: PeerHost\r\n    readonly host: PeerHost\r\n    readonly connections: ReadonlyArray<Peer.DataConnection>\r\n    readonly isHost: boolean\r\n    readonly error: Error | null\r\n}\r\n\r\nexport const usePeerHost = <TState, TAction extends Action = any>(\r\n    initialState: TState,\r\n    reducer?: Reducer<TState, TAction>\r\n): [TState, React.Dispatch<TAction>, PeerState] => {\r\n    const [state, _dispatch] = useReducer(reducer ?? emptyReducer, initialState)\r\n    const [peerState, setState] = useState<PeerState>({\r\n        peer: { id: null, ready: false },\r\n        host: { id: null, ready: false },\r\n        connections: [],\r\n        isHost: true,\r\n        error: null\r\n    })\r\n\r\n    const [peer, setPeer] = useState<Peer | null>(null)\r\n    const { connections } = peerState\r\n\r\n    const dispatch = useCallback((action: TAction, source: Peer.DataConnection | null = null) => {\r\n        // Send action to all connection except for source connection\r\n        connections.forEach(connection => source?.label !== connection.label\r\n            ? connection.send(action) : void (0))\r\n\r\n        // TODO: verify connection sends completed?\r\n        _dispatch(action)\r\n    }, [connections, _dispatch])\r\n\r\n    useEffect(\r\n        () => {\r\n            import('peerjs').then(({ default: peerConstructor }) => {\r\n                const peer = createPeer(peerConstructor)\r\n                setPeer(peer)\r\n\r\n                peer.on('error', error => setState(prev => ({ ...prev, error })))\r\n                peer.on('open', id => setState(prev => ({ ...prev, host: ({ id, ready: true }) })))\r\n\r\n                peer.on('connection', conn => {\r\n                    setState(prev => ({ ...prev, connections: [...prev.connections, conn] }))\r\n                    console.log(conn)\r\n                    // Send full state on open\r\n                    const action: InitialAction<TState> = {\r\n                        type: 'initialState',\r\n                        payload: state\r\n                    }\r\n                    conn.on('open', () => conn.send(action))\r\n\r\n                    conn.on('data', (data: TAction) => dispatch(data, conn))\r\n\r\n                    // Remove connection from active connections\r\n                    conn.on('close', () => setState(prev => ({ ...prev, connections: prev.connections.filter(x => x.label !== conn.label) })))\r\n                })\r\n            })\r\n\r\n            return () => {\r\n                peer && peer.destroy()\r\n            }\r\n        }, []\r\n    )\r\n\r\n    return [state, dispatch, peerState]\r\n}\r\n\r\nexport const usePeer = <TState, TAction extends Action = any>(\r\n    hostId: string,\r\n    reducer?: Reducer<TState, TAction>\r\n): [TState, React.Dispatch<TAction>, PeerState] => {\r\n    const combinedReducer = combineReducers<TState, TAction>(initialStateReducer, reducer ?? emptyReducer)\r\n    const [state, _dispatch] = useReducer(combinedReducer, null as any as TState) // TODO: fix dis type\r\n    const [peerState, setState] = useState<PeerState>({\r\n        peer: { id: null, ready: false },\r\n        host: { id: null, ready: true },\r\n        connections: [],\r\n        isHost: false,\r\n        error: null\r\n    })\r\n    const [peer, setPeer] = useState<Peer | null>(null)\r\n    const [host, setHost] = useState<Peer.DataConnection | null>(null)\r\n\r\n    const dispatch = useCallback((action: TAction) => {\r\n        if (host === null) throw new Error('Not connected to any host')\r\n\r\n        // Send action to host\r\n        host.send(action)\r\n\r\n        // TODO: verify host received?\r\n        _dispatch(action)\r\n    }, [host, _dispatch])\r\n\r\n    useEffect(\r\n        () => {\r\n            import('peerjs').then(({ default: peerConstructor }) => {\r\n                const peer = createPeer(peerConstructor)\r\n                setPeer(peer)\r\n\r\n                peer.on('error', error => setState(prev => ({ ...prev, error })))\r\n                peer.on('open', id => {\r\n                    const host = peer.connect(hostId)\r\n                    setHost(host)\r\n\r\n                    host.on('open', () => {\r\n                        setState(prev => ({ ...prev, host: ({ id: hostId, ready: true }) }))\r\n                    })\r\n\r\n                    host.on('data', (action: TAction) => {\r\n                        _dispatch(action)\r\n                    })\r\n                })\r\n            });\r\n\r\n            return () => {\r\n                peer && peer.destroy()\r\n                setState(prev => ({ ...prev, host: ({ id: null, ready: false }) }))\r\n            }\r\n        }, []\r\n    )\r\n\r\n    return [state, dispatch, peerState]\r\n}\r\n\r\nconst events = new EventEmitter()\r\n\r\nexport const useCommonPeer = <TState, TAction extends Action = any>(\r\n    hostId: string | null,  // broker id to connect. If null - create a new host\r\n    initialState?: TState,\r\n    reducer?: Reducer<TState, TAction>\r\n): [TState, React.Dispatch<TAction>, PeerState] => {\r\n    const combinedReducer = combineReducers<TState, TAction>(initialStateReducer, reducer ?? emptyReducer)\r\n\r\n    const [state, _dispatch] = useReducer(combinedReducer, initialState ?? null as any as TState) // TODO: fix this type\r\n    const [peerState, setState] = useState<PeerState>({\r\n        peer: { id: null, ready: false },\r\n        host: { id: null, ready: false },\r\n        connections: [],\r\n        isHost: false,\r\n        error: null\r\n    })\r\n\r\n    const [peer, setPeer] = useState<Peer | null>(null)\r\n    const [host, setHost] = useState<Peer.DataConnection | null>(null)\r\n    const { connections } = peerState\r\n\r\n    const dispatch = useCallback((action: TAction, source: Peer.DataConnection | null = null) => {\r\n        console.log('dispatching', action)\r\n        if (host !== null) {\r\n            // Send action to host\r\n            host.send(action)\r\n            // TODO: verify host received?\r\n        }\r\n        // Send action to all connection except for source connection\r\n        connections.forEach(connection => source?.label !== connection.label\r\n            ? connection.send(action) : void (0))\r\n\r\n        // TODO: verify connection sends completed?\r\n\r\n        _dispatch(action)\r\n    }, [host, connections, _dispatch])\r\n\r\n    const sendToConnection = useCallback((connection: Peer.DataConnection, action: Action) => {\r\n        connection.send(action)\r\n        console.log('sending to connection', action)\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        console.log('update initialstate dispatcher')\r\n        events.removeAllListeners()\r\n        // Send full state on open\r\n        const action: InitialAction<TState> = {\r\n            type: 'initialState',\r\n            payload: state\r\n        }\r\n        events.on('send-open-action', (connection: Peer.DataConnection) => sendToConnection(connection, action))\r\n    }, [state])\r\n\r\n    useEffect(\r\n        () => {\r\n            import('peerjs').then(({ default: peerConstructor }) => {\r\n                console.log('creating a new peer')\r\n                const peer = createPeer(peerConstructor)\r\n                setPeer(peer)\r\n\r\n                const connectToHost = (hostId: string) => {\r\n                    console.log('connection to a host')\r\n                    const host = peer.connect(hostId)\r\n                    setHost(host)\r\n                    host.on('open', () => {\r\n                        console.log('connection to host open')\r\n                        setState(prev => ({ ...prev, host: ({ id: hostId, ready: true }) }))\r\n                    })\r\n\r\n                    host.on('data', (action: TAction) => {\r\n                        console.log('received data on client', action)\r\n                        _dispatch(action)\r\n                    })\r\n                }\r\n\r\n                const createHost = (hostId: string) => {\r\n                    console.log('creating a host')\r\n                    setState(prev => ({ ...prev, isHost: true, host: { ...prev.host, id: hostId, ready: true } }))\r\n                    peer.on('connection', conn => {\r\n                        console.log('new connection to host', conn)\r\n                        setState(prev => ({ ...prev, connections: [...prev.connections, conn] }))\r\n                        conn.on('open', () => events.emit('send-open-action', conn))\r\n\r\n                        conn.on('data', (data: TAction) => {\r\n                            console.log('received data on host', data)\r\n                            dispatch(data, conn)\r\n                        })\r\n\r\n                        // Remove connection from active connections\r\n                        conn.on('close', () => setState(prev => ({ ...prev, connections: prev.connections.filter(x => x.label !== conn.label) })))\r\n                    })\r\n                }\r\n\r\n                peer.on('error', error => {\r\n                    console.log('error happened', error)\r\n                    if (error.type === 'unavailable-id') return createHost(peerState.peer.id!)\r\n                    setState(prev => ({ ...prev, error: new Error(error.type) }))\r\n                })\r\n\r\n                peer.on('open', id => {\r\n                    console.log('peer with id is open', id)\r\n                    setState(prev => ({ ...prev, peer: { ...prev.peer, id, ready: true } }))\r\n                    if (hostId === null) createHost(id)\r\n                    else connectToHost(hostId)\r\n                })\r\n            })\r\n\r\n            return () => {\r\n                peer && peer.destroy()\r\n            }\r\n        }, []\r\n    )\r\n\r\n    return [state, dispatch, peerState]\r\n}\r\n\r\ntype InitialAction<TState> = {\r\n    type: 'initialState',\r\n    payload: TState\r\n}\r\n\r\nconst assertInitialStateAction = <TState, TAction extends Action>(action: TAction | InitialAction<TState>): action is InitialAction<TState> =>\r\n    action.type === 'initialState'\r\n\r\nconst emptyReducer = <TState, TAction extends Action>(state: TState, action: TAction) => state\r\n\r\nconst initialStateReducer = <TState, TAction extends Action>(state: TState, action: TAction) => {\r\n    return assertInitialStateAction<TState, TAction>(action)\r\n        ? action.payload\r\n        : state\r\n}","import { createAction, createReducer, ActionType } from 'typesafe-actions'\r\n\r\nexport const actions = {\r\n    addMessage: createAction('message/add')<string>()\r\n}\r\n\r\nexport const reducer = createReducer<{ messages: string[] }, ActionType<typeof actions>>({ messages: [] }, {\r\n    \"message/add\": (state, action) => ({ ...state, messages: [...state.messages, action.payload] }),\r\n})\r\n","import React, { useEffect } from 'react'\r\n\r\nimport { useRouteMatch, useHistory } from 'react-router-dom'\r\n\r\nimport { Button, TextField } from '@material-ui/core'\r\nimport { usePeer, useCommonPeer } from '../../p2p/usePeerState'\r\n\r\nimport { reducer, actions } from '../../basicChat/basicChatStore'\r\n\r\nexport type Props = {}\r\n\r\nexport const Team: React.FC<Props> = ({ }) => {\r\n    const match = useRouteMatch<{ id: string }>('/t/:id')\r\n    const history = useHistory()\r\n    const [textState, setState] = React.useState('')\r\n\r\n    const [state, dispatch, peer] = useCommonPeer(match?.params.id ?? null, { messages: [] }, reducer)\r\n\r\n    const send = React.useCallback((msg: string) => {\r\n        dispatch(actions.addMessage(msg))\r\n        setState('')\r\n    }, [dispatch])\r\n\r\n    useEffect(() => {\r\n        if (match?.params.id === undefined && peer.host.id !== null) history.push(`/t/${peer.host.id}`)\r\n    }, [match, peer.host.id])\r\n\r\n    if (peer.error !== null)\r\n        return (<code>{peer.error.message}</code>)\r\n\r\n    if (!peer.host.ready)\r\n        return (<p>Loading...</p>)\r\n\r\n    if (state === null)\r\n        return (<p>No state</p>)\r\n\r\n    return (\r\n        <>\r\n            <div>Current peer id: <code>{peer.peer.id}</code> Ready {peer.peer.ready}</div>\r\n            <div>Host id: <code>{peer.host.id}</code> Ready {peer.host.ready}</div>\r\n            <div>Connected to me: <code>{peer.connections.map(x => x.label).join(', ')}</code></div>\r\n\r\n            {state.messages.map((msg, key) => <p key={key}>{msg}</p>)}\r\n            <TextField value={textState} onChange={event => setState(event.currentTarget.value)}></TextField>\r\n            <Button onClick={() => send(textState)}>Send</Button>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default Team","import React from 'react'\r\n\r\nimport { Switch, Route, Redirect } from 'react-router-dom'\r\nimport Lobby from './lobby'\r\nimport Team from './team'\r\n\r\nfunction App() {\r\n  return (\r\n    <Switch>\r\n      <Route path=\"/t/:id\">\r\n        <Team />\r\n      </Route>\r\n      <Route path=\"/\">\r\n        <Redirect to=\"/t/\" />\r\n      </Route>\r\n    </Switch>\r\n  )\r\n}\r\n\r\nexport default App\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(\r\n      process.env.PUBLIC_URL,\r\n      window.location.href\r\n    );\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' }\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react'\r\n\r\nimport { BrowserRouter } from \"react-router-dom\"\r\n\r\nexport type Props = {}\r\n\r\nexport const RouterOutlet: React.FC<Props> = ({ children }) => {\r\n    return (\r\n        <BrowserRouter>\r\n            {children}\r\n        </BrowserRouter>\r\n    )\r\n}\r\n\r\nexport default RouterOutlet","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport App from './app/App'\r\nimport * as serviceWorker from './serviceWorker'\r\nimport RouterOutlet from './app/router'\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <RouterOutlet>\r\n      <App />\r\n    </RouterOutlet>\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n)\r\n\r\nserviceWorker.unregister()\r\n"],"sourceRoot":""}