{"version":3,"sources":["p2p/usePeerState.ts","p2p/core.ts","utils/useEventListener.ts","app/modules/chat.ts","app/team/index.tsx","app/PeerProvider.tsx","app/App.tsx","serviceWorker.ts","app/router/index.tsx","index.tsx"],"names":["context","createContext","toInternalPeer","connection","id","peer","send","action","selfEmit","events","selfPeer","selfRefAsHost","emit","selfRefAsPeer","usePeerConnection","hostId","useState","EventEmitter","ready","host","connections","isHost","error","peerState","setState","setPeer","setHost","peerDispatch","useCallback","console","log","peerBroadcast","source","forEach","useEffect","then","peerConstructor","default","secure","createHost","prev","on","conn","filter","x","type","Error","connect","serialization","connectToHost","destroy","useDataListen","actionCreator","handler","deps","eventName","savedHandler","useRef","current","listener","removeListener","useEventListener","isActionOf","actions","login","createAction","loginResponse","newUser","sendMessage","receiveMessage","useChat","connecting","currentUser","messages","users","state","useContext","dispatch","broadcast","username","message","userId","payload","newState","newMessage","author","find","text","Team","React","textState","chatState","name","msg","TextField","value","onChange","event","currentTarget","Button","onClick","map","key","PeerProvider","route","children","match","useRouteMatch","history","useHistory","params","undefined","push","Provider","App","path","Boolean","window","location","hostname","RouterOutlet","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","registration","unregister","catch"],"mappings":"kPA4CaA,EAAUC,wBAAoD,MAMrEC,EAAiB,SAACC,GAAD,MAA6D,CAChFC,GAAID,EAAWE,KACfC,KAAM,SAAAC,GAAM,OAAIJ,EAAWG,KAAKC,MAG9BC,EAAW,SAACC,EAAqBC,EAAgBH,GACnD,IAAMI,EAAuC,CACzCP,GAAIM,EAASN,GACbE,KAAM,SAAAC,GACFE,EAAOG,KAAK,YAAaC,EAAeN,GACxCE,EAAOG,KAAK,WAAYC,EAAeN,KAGzCM,EAAuC,CACzCT,GAAIM,EAASN,GACbE,KAAM,SAAAC,GACFE,EAAOG,KAAK,YAAaD,EAAeJ,GACxCE,EAAOG,KAAK,WAAYD,EAAeJ,KAG/CE,EAAOG,KAAK,YAAaC,EAAeN,GACxCE,EAAOG,KAAK,WAAYC,EAAeN,IAG9BO,EAAoB,SAC7BC,GACwD,IAAD,EACtCC,mBAAsB,IAAIC,gBAApCR,EADgD,sBAEzBO,mBAAoB,CAC9CX,KAAM,CAAED,GAAI,KAAMc,OAAO,GACzBC,KAAM,CAAEf,GAAI,KAAMc,OAAO,GACzBE,YAAa,GACbC,QAAQ,EACRC,MAAO,OAP4C,mBAEhDC,EAFgD,KAErCC,EAFqC,OAU/BR,mBAAsB,MAVS,mBAUhDX,EAVgD,KAU1CoB,EAV0C,OAW/BT,mBAAqC,MAXN,mBAWhDG,EAXgD,KAW1CO,EAX0C,KAa/CN,EAAgBG,EAAhBH,YAEFO,EAAeC,uBAAY,SAACrB,GAC9BsB,QAAQC,IAAI,mBAAoBX,GACnB,OAATA,GAEAA,EAAKb,KAAKC,GAIVgB,EAAUF,QACVb,EAASC,EAAQJ,EAAOE,KAC7B,CAACY,EAAMI,EAAUF,SAEdU,EAAgBH,uBAAY,SAACrB,GAAiE,IAAjDyB,EAAgD,uDAAT,KACtFH,QAAQC,IAAI,0BAA2BV,GAEvCA,EAAYa,SAAQ,SAAA9B,GAAU,OAAU,OAAN6B,QAAM,IAANA,OAAA,EAAAA,EAAQ5B,MAAOD,EAAWC,GACtDD,EAAWG,KAAKC,QAAU,KAE5BgB,EAAUF,QACVb,EAASC,EAAQJ,EAAOE,KAC7B,CAACa,EAAaG,EAAUF,SAqE3B,OAnEAa,qBACI,WA4DI,OA3DA,wDAAiBC,MAAK,YAAmC,IAAvBC,EAAsB,EAA/BC,QACfhC,EChHsC,IDgHpB+B,EChHwC,CAC5EjB,KAHW,mCAIXmB,QAAQ,ID+GIb,EAAQpB,GAERwB,QAAQC,IAAI,eAAgBzB,GAE5B,IAiBMkC,EAAa,SAACxB,GAChBc,QAAQC,IAAI,mBACZrB,EAAOG,KAAK,QAEZY,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBnB,QAAQ,EAAMF,KAAK,eAAMqB,EAAKrB,KAAZ,CAAkBf,GAAIW,EAAQG,OAAO,SACpFb,EAAKoC,GAAG,cAAc,SAAAC,GAClBb,QAAQC,IAAI,0BAEZN,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBpB,YAAY,GAAD,mBAAMoB,EAAKpB,aAAX,CAAwBlB,EAAewC,UAC/EA,EAAKD,GAAG,QAAQ,kBAAMhC,EAAOG,KAAK,YAAaV,EAAewC,OAE9DA,EAAKD,GAAG,QAAQ,SAAClC,GACbsB,QAAQC,IAAI,0BAEZrB,EAAOG,KAAK,YAAaV,EAAewC,GAAOnC,GAC/CE,EAAOG,KAAK,WAAYV,EAAewC,GAAOnC,MAIlDmC,EAAKD,GAAG,SAAS,kBAAMjB,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBpB,YAAaoB,EAAKpB,YAAYuB,QAAO,SAAAC,GAAC,OAAIA,EAAExC,KAAOF,EAAewC,GAAMtC,kBAIpIC,EAAKoC,GAAG,SAAS,SAAAnB,GAEb,GADAO,QAAQC,IAAI,iBAAkBR,GACX,mBAAfA,EAAMuB,KAA2B,OAAON,EAAWhB,EAAUlB,KAAKD,IACtEoB,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBlB,MAAO,IAAIwB,MAAMxB,EAAMuB,cAGxDxC,EAAKoC,GAAG,QAAQ,SAAArC,GACZoB,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBnC,KAAK,eAAMmC,EAAKnC,KAAZ,CAAkBD,KAAIc,OAAO,SAC/C,OAAXH,EAAiBwB,EAAWnC,GAhDd,SAACW,GACnBc,QAAQC,IAAI,sBACZ,IAAMX,EAAOd,EAAK0C,QAAQhC,EAAQ,CAAEiC,cAAe,SACnDtB,EAAQP,GACRA,EAAKsB,GAAG,QAAQ,WACZZ,QAAQC,IAAI,gBACZN,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBrB,KAAO,CAAEf,GAAIW,EAAQG,OAAO,QACzDT,EAAOG,KAAK,YAAaV,EAAeiB,OAG5CA,EAAKsB,GAAG,QAAQ,SAAClC,GACbsB,QAAQC,IAAI,0BACZrB,EAAOG,KAAK,YAAaV,EAAeiB,GAAOZ,GAC/CE,EAAOG,KAAK,WAAYV,EAAeiB,GAAOZ,MAoC7C0C,CAAclC,SAIpB,WACHV,GAAQA,EAAK6C,aAElB,IAGA,CAAC3B,EAAWd,EAAQkB,EAAcI,IAGhCoB,EAAgB,SAGzB1C,EACA2C,EACAC,EACAC,IExL4B,SAC5BC,EACA9C,EACA4C,EACAC,GAEA,IAAME,EAAeC,iBAAcJ,GAInCnB,qBAAU,WACNsB,EAAaE,QAAUL,IACxBC,GAEHpB,qBACI,WACIL,QAAQC,IAAIyB,EAAWF,EAASC,GAChC,IAAMK,EAAW,kBAAoBH,EAAaE,QAAb,MAAAF,EAAY,YAGjD,OAFA/C,EAAOgC,GAAGc,EAAWI,GAEd,WACHlD,EAAOmD,eAAeL,EAAWI,MAGzC,CAACJ,IFkKLM,CAAiB,WAAYpD,GAAQ,SAACiC,EAAMnC,GACpCuD,qBAAWV,EAAe7C,IAC1B8C,EAAQX,EAAMnC,KAFN,CAIZ6C,GAJY,mBAIME,MG1LpBS,EAAU,CAEZC,MAAOC,uBAAa,QAAbA,GAEPC,cAAeD,uBAAa,iBAAbA,GACfE,QAASF,uBAAa,YAAbA,GAETG,YAAaH,uBAAa,eAAbA,GACbI,eAAgBJ,uBAAa,kBAAbA,IAoBPK,EAAU,WAAO,IAAD,EACCtD,mBAAoB,CAAEuD,YAAY,EAAMC,YAAa,KAAMC,SAAU,GAAIC,MAAO,KADjF,mBAClBC,EADkB,KACXnD,EADW,OHUlBoD,qBAAW5E,GGVO,mBAEPS,GAFO,WAECoE,EAFD,KAEWC,EAFX,KAInBd,EAAQpC,uBAAY,SAACmD,GACvBF,EAASd,EAAQC,MAAMe,MACxB,CAACF,IAEET,EAAcxC,uBAAY,SAACoD,GAC7BH,EAASd,EAAQK,YAAYY,MAC9B,CAACH,IAoCJ,OAlCA3C,qBAAU,WACNzB,EAAOgC,GAAG,aAAa,kBAAMjB,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgB+B,YAAY,UACtE9D,EAAOgC,GAAG,QAAQ,kBAAMjB,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgB+B,YAAY,YAClE,IAEHpB,EAAc1C,EAAQsD,EAAQC,OAAO,SAAC3D,EAAME,GACxCsB,QAAQC,IAAI,YACZ,IAAMqC,EAAoB,CAAEc,OAAQ5E,EAAKD,GAAI2E,SAAUxE,EAAO2E,SACxDC,EAAmB,eAAQR,EAAR,CAAeD,MAAM,GAAD,mBAAMC,EAAMD,OAAZ,CAAmBP,MAChE9D,EAAKC,KAAKyD,EAAQG,cAAR,eAA2BiB,EAA3B,CAAqCX,YAAaL,MAC5DW,EAAUf,EAAQI,QAAQA,GAAU9D,KACrC,CAACsE,EAAOG,IAEX3B,EAAc1C,EAAQsD,EAAQI,SAAS,SAAC9D,EAAME,GAC1CsB,QAAQC,IAAI,eACZN,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBkC,MAAM,GAAD,mBAAMlC,EAAKkC,OAAX,CAAkBnE,EAAO2E,iBAC5D,CAACP,IAEJxB,EAAc1C,EAAQsD,EAAQG,eAAe,SAAC7D,EAAME,GAChDsB,QAAQC,IAAI,iBACZN,EAASjB,EAAO2E,WACjB,IAEH/B,EAAc1C,EAAQsD,EAAQK,aAAa,SAAC/D,EAAME,GAC9CsB,QAAQC,IAAI,eACZ,IAAMsD,EAAsB,CAAEC,OAAQV,EAAMD,MAAMY,MAAK,SAAA1C,GAAC,OAAIA,EAAEqC,SAAW5E,EAAKD,MAAMmF,KAAMhF,EAAO2E,SACjGJ,EAAUf,EAAQM,eAAee,MAClC,CAACT,EAAMD,MAAOI,IAEjB3B,EAAc1C,EAAQsD,EAAQM,gBAAgB,SAAChE,EAAME,GACjDsB,QAAQC,IAAI,cACZN,GAAS,SAAAgB,GAAI,sBAAUA,EAAV,CAAgBiC,SAAS,GAAD,mBAAMjC,EAAKiC,UAAX,CAAqBlE,EAAO2E,iBAClE,IAEI,CAACP,EAAOX,EAAOI,ICvCXoB,EAlCsB,SAAC,GAAS,qBACbC,IAAMzE,SAAS,IADH,mBACnC0E,EADmC,KACxBlE,EADwB,OAEJ8C,IAFI,mBAEnCqB,EAFmC,KAExB7D,EAFwB,KAEnBsC,EAFmB,KAIpCJ,EAAQpC,uBAAY,SAACgE,GACvB9D,EAAI8D,GACJpE,EAAS,MACV,CAACM,IAEExB,EAAOsB,uBAAY,SAACiE,GACtBzB,EAAYyB,GACZrE,EAAS,MACV,CAAC4C,IAEJ,OAAIuB,EAAUpB,WACF,qDAEkB,OAA1BoB,EAAUnB,YAEN,oCACI,iDACA,kBAACsB,EAAA,EAAD,CAAWC,MAAOL,EAAWM,SAAU,SAAAC,GAAK,OAAIzE,EAASyE,EAAMC,cAAcH,UAC7E,kBAACI,EAAA,EAAD,CAAQC,QAAS,kBAAMpC,EAAM0B,KAA7B,SAIR,oCACKC,EAAUlB,SAAS4B,KAAI,SAACR,EAAKS,GAAN,OAAc,uBAAGA,IAAKA,GAAR,IAAeT,EAAIR,OAAON,SAA1B,IAAqCc,EAAIN,SAC/E,kBAACO,EAAA,EAAD,CAAWC,MAAOL,EAAWM,SAAU,SAAAC,GAAK,OAAIzE,EAASyE,EAAMC,cAAcH,UAC7E,kBAACI,EAAA,EAAD,CAAQC,QAAS,kBAAM9F,EAAKoF,KAA5B,UC9BCa,EAAgC,SAAC,GAAkC,IAAD,MAA/BC,aAA+B,MAAvB,OAAuB,EAAfC,EAAe,EAAfA,SACtDC,EAAQC,YAAa,WAAqBH,EAArB,SACrBI,EAAUC,cAEVxG,EAAOS,EAAiB,iBAAC4F,QAAD,IAACA,OAAD,EAACA,EAAOI,OAAO1G,UAAf,QAAqB,MAJwB,cAKrCC,EALqC,GAKpEkB,EALoE,eAY3E,OALAW,qBAAU,gBACmB6E,KAAhB,OAALL,QAAK,IAALA,OAAA,EAAAA,EAAOI,OAAO1G,KAA0C,OAAtBmB,EAAUJ,KAAKf,IACjDwG,EAAQI,KAAR,WAAiBR,EAAjB,YAA0BjF,EAAUJ,KAAKf,OAC9C,CAACsG,EAAOnF,EAAUJ,KAAKf,GAAIwG,IAG1B,kBAAC5G,EAAQiH,SAAT,CAAkBlB,MAAO1F,GACpBoG,ICAES,MAjBf,WACE,OACE,kBAAC,IAAD,KACE,kBAAC,IAAD,CAAOC,KAAK,UACV,kBAAC,EAAD,KACE,kBAAC,EAAD,QAGJ,kBAAC,IAAD,CAAOA,KAAK,KACV,kBAAC,EAAD,KACE,kBAAC,EAAD,UCJUC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASb,MACvB,2D,YCNSc,EARuB,SAAC,GAAkB,IAAhBf,EAAe,EAAfA,SACrC,OACI,kBAAC,IAAD,KACKA,ICDbgB,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,KACE,kBAAC,EAAD,QAGJC,SAASC,eAAe,SF+HpB,kBAAmBC,WACrBA,UAAUC,cAAc7G,MACrBiB,MAAK,SAAA6F,GACJA,EAAaC,gBAEdC,OAAM,SAAA5G,GACLO,QAAQP,MAAMA,EAAM0D,c","file":"static/js/main.be6cdd69.chunk.js","sourcesContent":["import { useEffect, useState, useReducer, useCallback, Reducer, useMemo, useContext, createContext, DependencyList } from 'react'\nimport Peer from 'peerjs'\nimport { Action, isActionOf } from 'typesafe-actions'\nimport { EventEmitter } from 'events'\nimport { StrictEventEmitter } from 'strict-event-emitter-types'\nimport { createPeer } from 'p2p/core'\nimport { useEventListener } from 'utils/useEventListener'\nimport { ActionCreator } from 'typesafe-actions/dist/is-action-of'\n\ntype PeerHost = {\n    id: string | null,\n    ready: boolean\n}\n\ntype PeerState = {\n    readonly peer: PeerHost\n    readonly host: PeerHost\n    readonly connections: ReadonlyArray<InternalPeerReference>\n    readonly isHost: boolean\n    readonly error: Error | null\n}\n\nexport type InternalPeerReference = {\n    id: string\n    send: <T extends Action = Action>(action: T) => void\n}\n\nexport type PeerDataEvent<T extends Action = Action> = (peer: InternalPeerReference, action: T) => void\n\nexport type PeerEvents = {\n    'any/data': PeerDataEvent\n\n    'open': () => void\n    'peer/open': (peer: InternalPeerReference) => void\n    'peer/data': PeerDataEvent\n\n    'host/open': (perr: InternalPeerReference) => void\n    'host/data': PeerDataEvent\n}\n\nexport type PeerEmmiter = StrictEventEmitter<EventEmitter, PeerEvents>\n\ntype PeerDispatch = (action: Action, source?: InternalPeerReference) => void\n\nexport const context = createContext<ReturnType<typeof usePeerConnection>>(null as any) // fix dis?\n\nexport const usePeer = () => {\n    return useContext(context)\n}\n\nconst toInternalPeer = (connection: Peer.DataConnection): InternalPeerReference => ({\n    id: connection.peer,\n    send: action => connection.send(action)\n})\n\nconst selfEmit = (events: PeerEmmiter, selfPeer: Peer, action: Action) => {\n    const selfRefAsHost: InternalPeerReference = {\n        id: selfPeer.id,\n        send: action => {\n            events.emit('host/data', selfRefAsPeer, action)\n            events.emit('any/data', selfRefAsPeer, action)\n        }\n    }\n    const selfRefAsPeer: InternalPeerReference = {\n        id: selfPeer.id,\n        send: action => {\n            events.emit('peer/data', selfRefAsHost, action)\n            events.emit('any/data', selfRefAsHost, action)\n        }\n    }\n    events.emit('host/data', selfRefAsPeer, action)\n    events.emit('any/data', selfRefAsPeer, action)\n}\n\nexport const usePeerConnection = (\n    hostId: string | null,  // broker id to connect. If null - create a new host\n): [PeerState, PeerEmmiter, PeerDispatch, PeerDispatch] => {\n    const [events] = useState<PeerEmmiter>(new EventEmitter())\n    const [peerState, setState] = useState<PeerState>({\n        peer: { id: null, ready: false },\n        host: { id: null, ready: false },\n        connections: [],\n        isHost: false,\n        error: null\n    })\n\n    const [peer, setPeer] = useState<Peer | null>(null)\n    const [host, setHost] = useState<Peer.DataConnection | null>(null)\n\n    const { connections } = peerState\n\n    const peerDispatch = useCallback((action: Action) => {\n        console.log('dispatch to host', host)\n        if (host !== null) {\n            // Send action to host\n            host.send(action)\n            // TODO: verify host received?\n        }\n\n        if (peerState.isHost)\n            selfEmit(events, peer!, action)\n    }, [host, peerState.isHost])\n\n    const peerBroadcast = useCallback((action: Action, source: InternalPeerReference | null = null) => {\n        console.log('dispatch to connections', connections)\n        // Send action to all connection except for source connection\n        connections.forEach(connection => source?.id !== connection.id\n            ? connection.send(action) : void (0))\n\n        if (peerState.isHost)\n            selfEmit(events, peer!, action)\n    }, [connections, peerState.isHost])\n\n    useEffect(\n        () => {\n            import('peerjs').then(({ default: peerConstructor }) => {\n                const peer = createPeer(peerConstructor)\n                setPeer(peer)\n\n                console.log('peer created', peer)\n\n                const connectToHost = (hostId: string) => {\n                    console.log('connecting to host')\n                    const host = peer.connect(hostId, { serialization: 'json' })\n                    setHost(host)\n                    host.on('open', () => {\n                        console.log('host is open')\n                        setState(prev => ({ ...prev, host: ({ id: hostId, ready: true }) }))\n                        events.emit('host/open', toInternalPeer(host))\n                    })\n\n                    host.on('data', (action: any) => {\n                        console.log('receive data from host')\n                        events.emit('host/data', toInternalPeer(host), action)\n                        events.emit('any/data', toInternalPeer(host), action)\n                    })\n                }\n\n                const createHost = (hostId: string) => {\n                    console.log('creating a host')\n                    events.emit('open')\n\n                    setState(prev => ({ ...prev, isHost: true, host: { ...prev.host, id: hostId, ready: true } }))\n                    peer.on('connection', conn => {\n                        console.log('peer connected to host')\n\n                        setState(prev => ({ ...prev, connections: [...prev.connections, toInternalPeer(conn)] }))\n                        conn.on('open', () => events.emit('peer/open', toInternalPeer(conn)))\n\n                        conn.on('data', (action: any) => {\n                            console.log('receive data from peer')\n\n                            events.emit('peer/data', toInternalPeer(conn), action)\n                            events.emit('any/data', toInternalPeer(conn), action)\n                        })\n\n                        // Remove connection from active connections\n                        conn.on('close', () => setState(prev => ({ ...prev, connections: prev.connections.filter(x => x.id !== toInternalPeer(conn).id) })))\n                    })\n                }\n\n                peer.on('error', error => {\n                    console.log('error happened', error)\n                    if (error.type === 'unavailable-id') return createHost(peerState.peer.id!)\n                    setState(prev => ({ ...prev, error: new Error(error.type) }))\n                })\n\n                peer.on('open', id => {\n                    setState(prev => ({ ...prev, peer: { ...prev.peer, id, ready: true } }))\n                    if (hostId === null) createHost(id)\n                    else connectToHost(hostId)\n                })\n            })\n\n            return () => {\n                peer && peer.destroy()\n            }\n        }, []\n    )\n\n    return [peerState, events, peerDispatch, peerBroadcast]\n}\n\nexport const useDataListen = <\n    AC extends ActionCreator<Action>\n>(\n    events: PeerEmmiter,\n    actionCreator: AC,\n    handler: PeerDataEvent<ReturnType<AC>>,\n    deps: DependencyList\n) => {\n    useEventListener('any/data', events, (conn, action) => {\n        if (isActionOf(actionCreator, action)) {\n            handler(conn, action)\n        }\n    }, [actionCreator, ...deps])\n}","import Peer from 'peerjs'\n\nconst server = 'peerjs-test-server.herokuapp.com'\n\nexport const createPeer = (peerConsturctor: typeof Peer) => new peerConsturctor({\n    host: server,\n    secure: true,\n}) ","import { useRef, useEffect, useState, DependencyList } from 'react'\nimport { EventEmitter } from 'events'\nimport StrictEventEmitter from 'strict-event-emitter-types/types/src'\n\n// event listener hook with mutating handler refence to optimize it for state changes\nexport const useEventListener = <E extends Record<string, (...arg: any) => any>, EK extends keyof E>(\n    eventName: EK,\n    events: StrictEventEmitter<EventEmitter, E>,\n    handler: E[EK],\n    deps: DependencyList\n) => {\n    const savedHandler = useRef<E[EK]>(handler)\n\n    // Update ref.current value if handler changes\n    // instead of removing and adding listener everytime\n    useEffect(() => {\n        savedHandler.current = handler\n    }, deps)\n\n    useEffect(\n        () => {\n            console.log(eventName, handler, deps)\n            const listener = (...args: any[]) => savedHandler.current(...args)\n            events.on(eventName, listener)\n\n            return () => {\n                events.removeListener(eventName, listener);\n            };\n        },\n        [eventName] // Re-run if eventName or element changes\n    );\n};\n","import { usePeer, PeerEmmiter, PeerEvents, PeerDataEvent, useDataListen } from \"p2p/usePeerState\"\nimport { createAction, isActionOf, Action, ActionType } from \"typesafe-actions\"\nimport { useState, useCallback, useEffect } from \"react\"\nimport { useEventListener } from \"utils/useEventListener\"\nimport StrictEventEmitter from \"strict-event-emitter-types/types/src\"\nimport { EventEmitter } from \"events\"\nimport { ActionCreator } from \"typesafe-actions/dist/is-action-of\"\nimport Peer from \"peerjs\"\n\nconst actions = {\n    // user asks to login\n    login: createAction('login')<string>(),\n    // server answering to login request\n    loginResponse: createAction('login/response')<ChatState>(),\n    newUser: createAction('login/new')<UserInfo>(),\n\n    sendMessage: createAction('message/send')<string>(),\n    receiveMessage: createAction('message/receive')<Message>(),\n}\n\ntype UserInfo = {\n    username: string\n    userId: string\n}\n\ntype Message = {\n    text: string\n    author: UserInfo\n}\n\ntype ChatState = {\n    connecting: boolean\n    currentUser: UserInfo | null\n    users: UserInfo[]\n    messages: Message[]\n}\n\nexport const useChat = () => {\n    const [state, setState] = useState<ChatState>({ connecting: true, currentUser: null, messages: [], users: [] })\n    const [peerState, events, dispatch, broadcast] = usePeer()\n\n    const login = useCallback((username: string) => {\n        dispatch(actions.login(username))\n    }, [dispatch])\n\n    const sendMessage = useCallback((message: string) => {\n        dispatch(actions.sendMessage(message))\n    }, [dispatch])\n\n    useEffect(() => {\n        events.on('host/open', () => setState(prev => ({ ...prev, connecting: false })))\n        events.on('open', () => setState(prev => ({ ...prev, connecting: false })))\n    }, [])\n\n    useDataListen(events, actions.login, (peer, action) => {\n        console.log('on login')\n        const newUser: UserInfo = { userId: peer.id, username: action.payload }\n        const newState: ChatState = { ...state, users: [...state.users, newUser] }\n        peer.send(actions.loginResponse({ ...newState, currentUser: newUser }))\n        broadcast(actions.newUser(newUser), peer)\n    }, [state, broadcast])\n\n    useDataListen(events, actions.newUser, (peer, action) => {\n        console.log('on new user')\n        setState(prev => ({ ...prev, users: [...prev.users, action.payload] }))\n    }, [state])\n\n    useDataListen(events, actions.loginResponse, (peer, action) => {\n        console.log('on login resp')\n        setState(action.payload)\n    }, [])\n\n    useDataListen(events, actions.sendMessage, (peer, action) => {\n        console.log('on send msg')\n        const newMessage: Message = { author: state.users.find(x => x.userId === peer.id)!, text: action.payload }\n        broadcast(actions.receiveMessage(newMessage))\n    }, [state.users, broadcast])\n\n    useDataListen(events, actions.receiveMessage, (peer, action) => {\n        console.log('on receive')\n        setState(prev => ({ ...prev, messages: [...prev.messages, action.payload] }))\n    }, [])\n\n    return [state, login, sendMessage] as const\n}","import React, { useEffect, useCallback } from 'react'\n\nimport { useRouteMatch, useHistory } from 'react-router-dom'\n\nimport { Button, TextField } from '@material-ui/core'\nimport { usePeerConnection } from 'p2p/usePeerState'\nimport { useChat } from 'app/modules/chat'\n\nexport type Props = {}\n\nexport const Team: React.FC<Props> = ({ }) => {\n    const [textState, setState] = React.useState('')\n    const [chatState, log, sendMessage] = useChat()\n\n    const login = useCallback((name: string) => {\n        log(name)\n        setState('')\n    }, [log])\n\n    const send = useCallback((msg: string) => {\n        sendMessage(msg)\n        setState('')\n    }, [sendMessage])\n\n    if (chatState.connecting)\n        return (<>Connecting...</>)\n\n    if (chatState.currentUser === null)\n        return (\n            <>\n                <div>Choose username:</div>\n                <TextField value={textState} onChange={event => setState(event.currentTarget.value)}></TextField>\n                <Button onClick={() => login(textState)}>Send</Button>\n            </>\n        )\n    return (\n        <>\n            {chatState.messages.map((msg, key) => <p key={key}>[{msg.author.username}]{msg.text}</p>)}\n            <TextField value={textState} onChange={event => setState(event.currentTarget.value)}></TextField>\n            <Button onClick={() => send(textState)}>Send</Button>\n        </>\n    )\n}\n\nexport default Team","import React, { useEffect, createContext } from 'react'\nimport { useRouteMatch, useHistory, HashRouter } from 'react-router-dom'\n\nimport { usePeerConnection, context } from 'p2p/usePeerState'\n\ntype Props = {\n    route?: string\n}\n\nexport const PeerProvider: React.FC<Props> = ({ route = 'peer', children }) => {\n    const match = useRouteMatch<{ id: string }>(`/${route}/:id`)\n    const history = useHistory()\n\n    const peer = usePeerConnection(match?.params.id ?? null)\n    const [peerState, events, dispatch] = peer\n\n    useEffect(() => {\n        if (match?.params.id === undefined && peerState.host.id !== null)\n            history.push(`/${route}/${peerState.host.id}`)\n    }, [match, peerState.host.id, history])\n\n    return (\n        <context.Provider value={peer}>\n            {children}\n        </context.Provider>\n    )\n}\n\nexport default PeerProvider","import React from 'react'\n\nimport { Switch, Route, Redirect } from 'react-router-dom'\nimport Team from './team'\nimport { PeerProvider } from './PeerProvider'\n\nfunction App() {\n  return (\n    <Switch>\n      <Route path=\"/t/:id\">\n        <PeerProvider>\n          <Team />\n        </PeerProvider>\n      </Route>\n      <Route path=\"/\">\n        <PeerProvider>\n          <Team />\n        </PeerProvider>\n      </Route>\n    </Switch>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\n\nimport { HashRouter } from \"react-router-dom\"\n\nexport const RouterOutlet: React.FC = ({ children }) => {\n    return (\n        <HashRouter>\n            {children}\n        </HashRouter>\n    )\n}\n\nexport default RouterOutlet","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from 'app/App'\nimport * as serviceWorker from './serviceWorker'\nimport RouterOutlet from 'app/router'\n\nReactDOM.render(\n  <React.StrictMode>\n    <RouterOutlet>\n      <App />\n    </RouterOutlet>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\nserviceWorker.unregister()\n"],"sourceRoot":""}