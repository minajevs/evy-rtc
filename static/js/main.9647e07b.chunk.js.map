{"version":3,"sources":["utils/reducerHelpers.ts","p2p/core.ts","p2p/usePeerState.ts","basicChat/basicChatStore.ts","app/team/index.tsx","app/App.tsx","serviceWorker.ts","app/router/index.tsx","index.tsx"],"names":["combineReducers","reducers","state","action","reduce","reducer","createPeer","peerConsturctor","host","secure","events","EventEmitter","useCommonPeer","hostId","initialState","combinedReducer","initialStateReducer","emptyReducer","useReducer","_dispatch","useState","peer","id","ready","connections","isHost","error","peerState","setState","setPeer","setHost","dispatch","useCallback","source","console","log","send","forEach","connection","label","sendToConnection","useEffect","removeAllListeners","type","payload","on","then","peerConstructor","default","createHost","prev","conn","emit","data","filter","x","Error","connect","connectToHost","destroy","assertInitialStateAction","actions","addMessage","createAction","createReducer","messages","Team","match","useRouteMatch","history","useHistory","React","textState","params","msg","undefined","push","message","map","join","key","TextField","value","onChange","event","currentTarget","Button","onClick","App","path","Boolean","window","location","hostname","RouterOutlet","children","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","registration","unregister","catch"],"mappings":"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","file":"static/js/main.9647e07b.chunk.js","sourcesContent":["import { Reducer } from \"react\"\n\nexport const combineReducers = <TState, TActions>(...reducers: Reducer<TState, TActions>[]): Reducer<TState, TActions> => (state: TState, action: TActions) =>\n    reducers.reduce(\n        (state, reducer) => reducer(state, action),\n        state)","import Peer from 'peerjs'\n\nconst server = 'peerjs-test-server.herokuapp.com'\n\nexport const createPeer = (peerConsturctor: typeof Peer) => new peerConsturctor({\n    host: server,\n    secure: true\n}) ","import { useEffect, useState, useReducer, useCallback, Reducer, useMemo } from 'react'\nimport Peer from 'peerjs'\nimport { Action } from 'typesafe-actions'\n\nimport { combineReducers } from '../utils/reducerHelpers'\nimport { createPeer } from './core'\nimport { EventEmitter } from 'events'\n\ntype PeerHost = {\n    id: string | null,\n    ready: boolean\n}\n\ntype PeerState = {\n    readonly peer: PeerHost\n    readonly host: PeerHost\n    readonly connections: ReadonlyArray<Peer.DataConnection>\n    readonly isHost: boolean\n    readonly error: Error | null\n}\n\nexport const usePeerHost = <TState, TAction extends Action = any>(\n    initialState: TState,\n    reducer?: Reducer<TState, TAction>\n): [TState, React.Dispatch<TAction>, PeerState] => {\n    const [state, _dispatch] = useReducer(reducer ?? emptyReducer, initialState)\n    const [peerState, setState] = useState<PeerState>({\n        peer: { id: null, ready: false },\n        host: { id: null, ready: false },\n        connections: [],\n        isHost: true,\n        error: null\n    })\n\n    const [peer, setPeer] = useState<Peer | null>(null)\n    const { connections } = peerState\n\n    const dispatch = useCallback((action: TAction, source: Peer.DataConnection | null = null) => {\n        // Send action to all connection except for source connection\n        connections.forEach(connection => source?.label !== connection.label\n            ? connection.send(action) : void (0))\n\n        // TODO: verify connection sends completed?\n        _dispatch(action)\n    }, [connections, _dispatch])\n\n    useEffect(\n        () => {\n            import('peerjs').then(({ default: peerConstructor }) => {\n                const peer = createPeer(peerConstructor)\n                setPeer(peer)\n\n                peer.on('error', error => setState(prev => ({ ...prev, error })))\n                peer.on('open', id => setState(prev => ({ ...prev, host: ({ id, ready: true }) })))\n\n                peer.on('connection', conn => {\n                    setState(prev => ({ ...prev, connections: [...prev.connections, conn] }))\n                    console.log(conn)\n                    // Send full state on open\n                    const action: InitialAction<TState> = {\n                        type: 'initialState',\n                        payload: state\n                    }\n                    conn.on('open', () => conn.send(action))\n\n                    conn.on('data', (data: TAction) => dispatch(data, conn))\n\n                    // Remove connection from active connections\n                    conn.on('close', () => setState(prev => ({ ...prev, connections: prev.connections.filter(x => x.label !== conn.label) })))\n                })\n            })\n\n            return () => {\n                peer && peer.destroy()\n            }\n        }, []\n    )\n\n    return [state, dispatch, peerState]\n}\n\nexport const usePeer = <TState, TAction extends Action = any>(\n    hostId: string,\n    reducer?: Reducer<TState, TAction>\n): [TState, React.Dispatch<TAction>, PeerState] => {\n    const combinedReducer = combineReducers<TState, TAction>(initialStateReducer, reducer ?? emptyReducer)\n    const [state, _dispatch] = useReducer(combinedReducer, null as any as TState) // TODO: fix dis type\n    const [peerState, setState] = useState<PeerState>({\n        peer: { id: null, ready: false },\n        host: { id: null, ready: true },\n        connections: [],\n        isHost: false,\n        error: null\n    })\n    const [peer, setPeer] = useState<Peer | null>(null)\n    const [host, setHost] = useState<Peer.DataConnection | null>(null)\n\n    const dispatch = useCallback((action: TAction) => {\n        if (host === null) throw new Error('Not connected to any host')\n\n        // Send action to host\n        host.send(action)\n\n        // TODO: verify host received?\n        _dispatch(action)\n    }, [host, _dispatch])\n\n    useEffect(\n        () => {\n            import('peerjs').then(({ default: peerConstructor }) => {\n                const peer = createPeer(peerConstructor)\n                setPeer(peer)\n\n                peer.on('error', error => setState(prev => ({ ...prev, error })))\n                peer.on('open', id => {\n                    const host = peer.connect(hostId)\n                    setHost(host)\n\n                    host.on('open', () => {\n                        setState(prev => ({ ...prev, host: ({ id: hostId, ready: true }) }))\n                    })\n\n                    host.on('data', (action: TAction) => {\n                        _dispatch(action)\n                    })\n                })\n            });\n\n            return () => {\n                peer && peer.destroy()\n                setState(prev => ({ ...prev, host: ({ id: null, ready: false }) }))\n            }\n        }, []\n    )\n\n    return [state, dispatch, peerState]\n}\n\nconst events = new EventEmitter()\n\nexport const useCommonPeer = <TState, TAction extends Action = any>(\n    hostId: string | null,  // broker id to connect. If null - create a new host\n    initialState?: TState,\n    reducer?: Reducer<TState, TAction>\n): [TState, React.Dispatch<TAction>, PeerState] => {\n    const combinedReducer = combineReducers<TState, TAction>(initialStateReducer, reducer ?? emptyReducer)\n\n    const [state, _dispatch] = useReducer(combinedReducer, initialState ?? null as any as TState) // TODO: fix this type\n    const [peerState, setState] = useState<PeerState>({\n        peer: { id: null, ready: false },\n        host: { id: null, ready: false },\n        connections: [],\n        isHost: false,\n        error: null\n    })\n\n    const [peer, setPeer] = useState<Peer | null>(null)\n    const [host, setHost] = useState<Peer.DataConnection | null>(null)\n    const { connections } = peerState\n\n    const dispatch = useCallback((action: TAction, source: Peer.DataConnection | null = null) => {\n        console.log('dispatching', action)\n        if (host !== null) {\n            // Send action to host\n            host.send(action)\n            // TODO: verify host received?\n        }\n        // Send action to all connection except for source connection\n        connections.forEach(connection => source?.label !== connection.label\n            ? connection.send(action) : void (0))\n\n        // TODO: verify connection sends completed?\n\n        _dispatch(action)\n    }, [host, connections, _dispatch])\n\n    const sendToConnection = useCallback((connection: Peer.DataConnection, action: Action) => {\n        connection.send(action)\n        console.log('sending to connection', action)\n    }, [])\n\n    useEffect(() => {\n        console.log('update initialstate dispatcher')\n        events.removeAllListeners()\n        // Send full state on open\n        const action: InitialAction<TState> = {\n            type: 'initialState',\n            payload: state\n        }\n        events.on('send-open-action', (connection: Peer.DataConnection) => sendToConnection(connection, action))\n    }, [state])\n\n    useEffect(\n        () => {\n            import('peerjs').then(({ default: peerConstructor }) => {\n                console.log('creating a new peer')\n                const peer = createPeer(peerConstructor)\n                setPeer(peer)\n\n                const connectToHost = (hostId: string) => {\n                    console.log('connection to a host')\n                    const host = peer.connect(hostId)\n                    setHost(host)\n                    host.on('open', () => {\n                        console.log('connection to host open')\n                        setState(prev => ({ ...prev, host: ({ id: hostId, ready: true }) }))\n                    })\n\n                    host.on('data', (action: TAction) => {\n                        console.log('received data on client', action)\n                        _dispatch(action)\n                    })\n                }\n\n                const createHost = (hostId: string) => {\n                    console.log('creating a host')\n                    setState(prev => ({ ...prev, isHost: true, host: { ...prev.host, id: hostId, ready: true } }))\n                    peer.on('connection', conn => {\n                        console.log('new connection to host', conn)\n                        setState(prev => ({ ...prev, connections: [...prev.connections, conn] }))\n                        conn.on('open', () => events.emit('send-open-action', conn))\n\n                        conn.on('data', (data: TAction) => {\n                            console.log('received data on host', data)\n                            dispatch(data, conn)\n                        })\n\n                        // Remove connection from active connections\n                        conn.on('close', () => setState(prev => ({ ...prev, connections: prev.connections.filter(x => x.label !== conn.label) })))\n                    })\n                }\n\n                peer.on('error', error => {\n                    console.log('error happened', error)\n                    if (error.type === 'unavailable-id') return createHost(peerState.peer.id!)\n                    setState(prev => ({ ...prev, error: new Error(error.type) }))\n                })\n\n                peer.on('open', id => {\n                    console.log('peer with id is open', id)\n                    setState(prev => ({ ...prev, peer: { ...prev.peer, id, ready: true } }))\n                    if (hostId === null) createHost(id)\n                    else connectToHost(hostId)\n                })\n            })\n\n            return () => {\n                peer && peer.destroy()\n            }\n        }, []\n    )\n\n    return [state, dispatch, peerState]\n}\n\ntype InitialAction<TState> = {\n    type: 'initialState',\n    payload: TState\n}\n\nconst assertInitialStateAction = <TState, TAction extends Action>(action: TAction | InitialAction<TState>): action is InitialAction<TState> =>\n    action.type === 'initialState'\n\nconst emptyReducer = <TState, TAction extends Action>(state: TState, action: TAction) => state\n\nconst initialStateReducer = <TState, TAction extends Action>(state: TState, action: TAction) => {\n    return assertInitialStateAction<TState, TAction>(action)\n        ? action.payload\n        : state\n}","import { createAction, createReducer, ActionType } from 'typesafe-actions'\n\nexport const actions = {\n    addMessage: createAction('message/add')<string>()\n}\n\nexport const reducer = createReducer<{ messages: string[] }, ActionType<typeof actions>>({ messages: [] }, {\n    \"message/add\": (state, action) => ({ ...state, messages: [...state.messages, action.payload] }),\n})\n","import React, { useEffect } from 'react'\n\nimport { useRouteMatch, useHistory } from 'react-router-dom'\n\nimport { Button, TextField } from '@material-ui/core'\nimport { usePeer, useCommonPeer } from '../../p2p/usePeerState'\n\nimport { reducer, actions } from '../../basicChat/basicChatStore'\n\nexport type Props = {}\n\nexport const Team: React.FC<Props> = ({ }) => {\n    const match = useRouteMatch<{ id: string }>('/t/:id')\n    const history = useHistory()\n    const [textState, setState] = React.useState('')\n\n    const [state, dispatch, peer] = useCommonPeer(match?.params.id ?? null, { messages: [] }, reducer)\n\n    const send = React.useCallback((msg: string) => {\n        dispatch(actions.addMessage(msg))\n        setState('')\n    }, [dispatch])\n\n    useEffect(() => {\n        if (match?.params.id === undefined && peer.host.id !== null) history.push(`/t/${peer.host.id}`)\n    }, [match, peer.host.id])\n\n    if (peer.error !== null)\n        return (<code>{peer.error.message}</code>)\n\n    if (!peer.host.ready)\n        return (<p>Loading...</p>)\n\n    if (state === null)\n        return (<p>No state</p>)\n\n    return (\n        <>\n            <div>Current peer id: <code>{peer.peer.id}</code> Ready {peer.peer.ready}</div>\n            <div>Host id: <code>{peer.host.id}</code> Ready {peer.host.ready}</div>\n            <div>Connected to me: <code>{peer.connections.map(x => x.label).join(', ')}</code></div>\n\n            {state.messages.map((msg, key) => <p key={key}>{msg}</p>)}\n            <TextField value={textState} onChange={event => setState(event.currentTarget.value)}></TextField>\n            <Button onClick={() => send(textState)}>Send</Button>\n        </>\n    )\n}\n\nexport default Team","import React from 'react'\n\nimport { Switch, Route, Redirect } from 'react-router-dom'\nimport Lobby from './lobby'\nimport Team from './team'\n\nfunction App() {\n  return (\n    <Switch>\n      <Route path=\"/t/:id\">\n        <Team />\n      </Route>\n      <Route path=\"/\">\n        <Team />\n      </Route>\n    </Switch>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react'\n\nimport { HashRouter } from \"react-router-dom\"\n\nexport type Props = {}\n\nexport const RouterOutlet: React.FC<Props> = ({ children }) => {\n    return (\n        // needs /evy because hosted on gh-pages\n        <HashRouter>\n            {children}\n        </HashRouter>\n    )\n}\n\nexport default RouterOutlet","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './app/App'\nimport * as serviceWorker from './serviceWorker'\nimport RouterOutlet from './app/router'\n\nReactDOM.render(\n  <React.StrictMode>\n    <RouterOutlet>\n      <App />\n    </RouterOutlet>\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\nserviceWorker.unregister()\n"],"sourceRoot":""}